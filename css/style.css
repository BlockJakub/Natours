/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/* BASIC RESET */
* {
    margin:0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: "Lato", sans-serif; /*  this fonta family will inherit all child element in body */
    font-weight: 400;
    font-size: 16px;
    line-height: 1.7;
    color: #777;
    padding: 30px;
}

.header {
    height: 95vh;
    background-image: linear-gradient(to right bottom,
     rgba(126, 213, 111, .8), 
     rgba(40, 180, 131, .8)), 
     url("../img/hero.jpg");
    background-size: cover; /* what ever size of viewport image fit in */
    background-position: top;
    position: relative;
    /* THE values of  polygon(x y, x y, x y, x y) */ 
    clip-path: polygon(0 0, 100% 0, 100% 78%, 0 100%);
}

.logo-box {
    position: absolute;
    top: 40px;
    left: 40px;
}

.logo {
    height: 35px;
}

.text-box {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%); 
    /* !!! BECAUSE of declared positions. 
    Without the transform:translate(-50%, -50%) IT WOULD BE SHIFTED HALF 50% down and right. */
    text-align: center;
}
.heading-primary {
    color: #fff;
    text-transform: uppercase;

    backface-visibility: hidden;
    margin-bottom: 60px;
}

.heading-primary-main {
    display: block;
    font-size: 60px;
    font-weight: 700;
    letter-spacing: 35px;
    animation: moveInRight .9s ease-out;
}

.heading-primary-sub {
    display: block;
    font-size: 20px;
    font-weight: 400;
    letter-spacing: 15px;
    animation: moveInLeft 1.3s ease-out;
}

@keyframes moveInLeft {
    0% {
        opacity: 0;
        transform: translateX(-100px);
    }

    80% {
        transform: translateX(10px);
    }
    100% {
        opacity: 1;
        transform:  translate(0);
    }
    
}

@keyframes moveInRight {
    0% {
        opacity: 0;
        transform: translateX(100px);
    }
    80% {
        transform: translateX(10px);
    }
    100% {
        opacity: 1;
        transform:  translate(0);
    }
}

@keyframes moveInBottom {
    0% {
        opacity: 0;
        transform: translateY(30px);
    }
    100% {
        opacity: 1;
        transform:  translate(0);
    }
}

/* SUDOCLASS :link state of the button, when the hovered or the button is clicked. 
    :visited state when you visit link it change the color to purple that is the default state of button element.
       Therefore we want the link color same as at the begining */
.btn:link,
.btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    padding: 15px 40px;
    display: inline-block;
    border-radius: 100px;
    transition: all .2s; 
    /* the transition property must be on initial state what is the .btn:link and .btn:visited or it doesn't work.
      Simply we saying here in parent element the transition can be used on all properties */
    position: relative;         
}

/* then on :hover we say how it should look like and on the :active state same */
.btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 10px 20px rgba(0,0,0, .2);
}

/* when we click the button box-shadow property is less see as we click the button in real world thanks the blur value*/
.btn:active {
    transform: translateY(-1px);
    box-shadow: 0 5px 10px rgba(0,0,0, .2);
}

.btn-white {
    background-color: #fff;
    color: #777;
}


/* ::after SUDO element we giving to it looks exactly same as the button we have, but is hidden behind the button and when we hover it hides.  */
.btn::after {
    content: "";
    display: inline-block;
    width: 100%;
    height: 100%;
    border-radius: 100px;
    position: absolute; /* !!!! THE position:absolute needs to have a reference and the reference is the first element with the relative postion that can find. In this case it is the header. But we want it hidden behind the button so we must give position: relative; to btn:link, .btn:visited.  !!!!!!!!!!! */
    top: 0;
    left: 0;
    z-index: -1; /* now it is behind the button */
    transition: all .4s; /* <---- The transition: all .4s; needs to be in initial state btn element(.btn::after {}), because we have the ::after SUDO element when is hovered transform: scale(1.5) animation. */ 
}

.btn-white::after {
    background-color: #fff;
}

.btn:hover::after { /* we want the ::after sudo element only when is the .btn hovered */
    transform: scaleX(1.4) scaleY(1.6);
    opacity: 0;
}

.btn-animated {
    animation: moveInBottom .5s ease-out .75s;
    animation-fill-mode: backwards;
}